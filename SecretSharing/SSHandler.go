package SecretSharing

import (
	"fmt"
	"sync"

	core "github.com/ksei/Peerster/Core"
	"golang.org/x/crypto/bcrypt"
)

const (
	MIN_ITER   = 2000
	MAX_ITER   = 3000
	MIN_SHARES = 6
)

type SSHandler struct {
	ssLocker        sync.RWMutex
	ctx             core.Context
	storedPasswords []string
	salts           map[string][]byte
	nonces          map[string][][]byte
}

func (ssHandler *SSHandler) handlePasswordInsert(masterKey, account, username, newPassword string) {

	//1. Assign Password UID and check if already inserted (for now we can start without supporting password upates)
	if ssHandler.passwordExists(masterKey, account, username) {
		fmt.Println("Password has been already registered. Updates are not supported at the moment.")
		return
	}
	passwordUID, err := ssHandler.registerPassword(masterKey, account, username)
	if err != nil {
		fmt.Println(err)
		return
	}
	//2. Encrypt password using key derived by master key + account + username
	encryptedPass, err := ssHandler.encryptPassword(masterKey, account, username, passwordUID, newPassword)
	if err != nil {
		fmt.Println(err)
		return
	}
	//3. Generate shares
	shares := [][]byte{}
	//4. Assign each share to an origin from dsdv
	sharePerPeer, err := ssHandler.mapSharesToPeers(shares)
	if err != nil {
		fmt.Println(err)
		return
	}
	//5. Create secret shares encrypting each share using key derived from master key + account + username + peer-to-be-sent-to
	//6. Create public shares using the secret share and a uid generated by the hash of password UID, peer that it is sent to and index of the share for that peer
	//encryptShares returns a map with origins as keys and public shares as values
	publicShares, err := ssHandler.encryptShares(masterKey, account, username, sharePerPeer)
	if err != nil {
		fmt.Println(err)
		return
	}
	//7. Send each public share to its destination
	err = ssHandler.distributePublicShares(publicShares)
	if err != nil {
		fmt.Println(err)
		return
	}
}

func (ssHandler *SSHandler) handlePasswordRetrieval(masterKey, account, username string) {
	//1. Assign Password UID and check if it exists
	//2. If yes, proceed by creating a search expanding ring using the uid
	//3. Wait until the threshold of unique received shares is received
	//4. Decrypt each share generating key by kdf with the same parameters as above
	//5. Reconstruct secret
	//6. Decrypt reconstructed secret using as key the kdf with same parameters as above
	//7. Return password
}

func (ssHandler *SSHandler) registerPassword(masterKey, account, username string) (string, error) {
	bytes, err := bcrypt.GenerateFromPassword([]byte(masterKey+account+username), bcrypt.DefaultCost)
	if err != nil {
		return "", err
	}
	ssHandler.ssLocker.Lock()
	defer ssHandler.ssLocker.Unlock()
	ssHandler.storedPasswords = append(ssHandler.storedPasswords, string(bytes))
	return string(bytes), err
}
